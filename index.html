<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta name="ac-discovery" content="blablacar.github.io https://github.com/blablacar/dgr/releases/download/{version}/dgr-{os}-{arch}-{version}.{ext}">
    <meta charset="UTF-8">
    <title>dgr by blablacar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">dgr</h1>
      <h2 class="project-tagline">Container build and runtime tool</h2>
      <a href="https://github.com/blablacar/dgr" class="btn">View on GitHub</a>
      <a href="https://github.com/blablacar/dgr/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/blablacar/dgr/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="dgr---container-build-and-runtime-tool" class="anchor" href="#dgr---container-build-and-runtime-tool" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>dgr - container build and runtime tool</h1>

<p><a href="https://goreportcard.com/report/github.com/blablacar/dgr"><img src="https://goreportcard.com/badge/github.com/blablacar/dgr" alt="Go Report Card"></a>
<a href="https://godoc.org/github.com/blablacar/dgr"><img src="https://img.shields.io/badge/godoc-reference-5874B0.svg" alt="GoDoc"></a>
<a href="https://travis-ci.org/blablacar/dgr"><img src="https://img.shields.io/travis/blablacar/dgr/master.svg" alt="Build Status"></a></p>

<p><img src="https://raw.githubusercontent.com/blablacar/dgr/gh-pages/logo.png" width="300"></p>

<p><strong>dgr</strong> (pronounced "<em>digg-er</em>") is a command line utility designed to build and to configure at runtime App Containers Images (<a href="https://github.com/appc/spec/blob/master/spec/aci.md">ACI</a>) and App Container Pods (<a href="https://github.com/appc/spec/blob/master/spec/pods.md">POD</a>) based on convention over configuration.</p>

<p>dgr allows you to build generic container images for a service and to configure them at runtime. Therefore you can use the same image for different environments, clusters, or nodes by overriding the appropriate attributes when launching the container.</p>

<p><em>dgr is actively used at blablacar to build and run more than an hundred different aci and pod to <a href="http://blablatech.com/blog/why-and-how-blablacar-went-full-containers">run all platforms</a>.</em></p>

<h2>
<a id="build-the-aci-once-configure-your-app-at-runtime" class="anchor" href="#build-the-aci-once-configure-your-app-at-runtime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Build the ACI once, configure your app at runtime.</h2>

<p>dgr provides various resources to build and configure an ACI:</p>

<ul>
<li>scripts at runlevels (build, prestart...)</li>
<li>templates and attributes</li>
<li>static files</li>
<li>images dependencies</li>
</ul>

<p><strong>Scripts</strong> are executed at the image build, before your container is started and more. See <a href="#runlevels">runlevels</a> for more information.</p>

<p><strong>Templates</strong> and <strong>attributes</strong> are the way dgr deals with environment-specific configurations. <strong>Templates</strong> are stored in the image and resolved at runtime ; <strong>attributes</strong> are inherited from different contexts (aci -&gt; pod -&gt; environment).</p>

<p><strong>Static files</strong> are copied to the same path in the container.</p>

<p><strong>Image dependencies</strong> are used as defined in <a href="https://github.com/appc/spec/blob/master/spec/aci.md#dependency-matching">APPC spec</a>.</p>

<p><img src="https://raw.githubusercontent.com/blablacar/dgr/gh-pages/aci-dummy.gif" alt="demo"></p>

<h2>
<a id="commands" class="anchor" href="#commands" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Commands</h2>

<div class="highlight highlight-source-shell"><pre>$ dgr init          <span class="pl-c"># init a sample project</span>
$ dgr build         <span class="pl-c"># build the image</span>
$ dgr clean         <span class="pl-c"># clean the build</span>
$ dgr clean build   <span class="pl-c"># just building, clean is always run before building</span>
$ dgr clean install <span class="pl-c"># clean, build and install aci in the local rkt</span>
$ dgr clean push    <span class="pl-c"># clean, build and push aci to remote storage</span>
$ dgr clean <span class="pl-c1">test</span>    <span class="pl-c"># clean, build and test aci</span>
$ dgr install       <span class="pl-c"># use already built aci in target directory to install in rkt</span>
$ dgr push          <span class="pl-c"># use already built aci in target directory to push to remote storage</span>
$ dgr <span class="pl-c1">test</span>          <span class="pl-c"># run tests on already built aci</span>
$ dgr try           <span class="pl-c"># run templating only to target/try (experimental)</span></pre></div>

<p>There is a lot of different flags on each command. use the helper to see them :</p>

<div class="highlight highlight-source-shell"><pre>$ dgr --help
...
$ dgr build --help
...</pre></div>

<h2>
<a id="configuration-file" class="anchor" href="#configuration-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration file</h2>

<p><em>Global configuration is optional to start as long as you have rkt in $PATH</em></p>

<p>dgr global configuration is a yaml file located at <code>~/.config/dgr/config.yml</code>. Home is the home of starting user (the caller user if running with sudo).</p>

<p><strong>targetWorkDir</strong> is used to indicate the target work directory where dgr will work to build and create the ACI
<strong>push</strong>* contain informations on how to push the aci/pod to remote storage
<strong>rkt</strong> if you are not using rkt in your path, or want to create specif config</p>

<p>Example of configuration:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">targetWorkDir:</span> <span class="pl-s">/tmp/target      </span></span><span class="pl-c"># if you want to use another directory for all builds</span>
<span class="pl-s"><span class="pl-ent">push:</span></span>
  <span class="pl-s"><span class="pl-ent">type:</span> <span class="pl-s">maven</span></span>
  <span class="pl-s"><span class="pl-ent">url:</span> <span class="pl-s">https://localhost/nexus</span></span>
  <span class="pl-s"><span class="pl-ent">username:</span> <span class="pl-s">admin</span></span>
  <span class="pl-s"><span class="pl-ent">password:</span> <span class="pl-s">admin</span></span>
<span class="pl-s"><span class="pl-ent">rkt:</span>                            </span><span class="pl-c"># arguments to rkt. See rkt --help</span>
  <span class="pl-s"><span class="pl-ent">path:</span></span>
  <span class="pl-s"><span class="pl-ent">insecureOptions:</span> <span class="pl-s">[image]</span></span>
  <span class="pl-s"><span class="pl-ent">dir:</span> <span class="pl-s">/var/lib/rkt</span></span>
  <span class="pl-s"><span class="pl-ent">localConfig:</span> <span class="pl-s">/etc/rkt</span></span>
  <span class="pl-s"><span class="pl-ent">systemConfig:</span> <span class="pl-s">/usr/lib/rkt</span></span>
  <span class="pl-s"><span class="pl-ent">userConfig:</span></span>
  <span class="pl-s"><span class="pl-ent">trustKeysFromHttps:</span> <span class="pl-s">false</span></span>
  <span class="pl-s"><span class="pl-ent">noStore:</span> <span class="pl-s">false                </span></span><span class="pl-c"># can be set by command line</span>
  <span class="pl-s"><span class="pl-ent">storeOnly:</span> <span class="pl-s">false              </span></span><span class="pl-c"># can be set by command line</span></pre></div>

<h1>
<a id="building-an-aci" class="anchor" href="#building-an-aci" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building an ACI</h1>

<h2>
<a id="initializing-a-new-project" class="anchor" href="#initializing-a-new-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Initializing a new project</h2>

<p>Run the following commands to initialize a new complete sample project:</p>

<div class="highlight highlight-source-shell"><pre>$ mkdir aci-myapp
$ <span class="pl-c1">cd</span> aci-myapp
$ dgr init</pre></div>

<p>It will generate the following file tree:</p>

<pre lang="text"><code>.
|-- attributes
|   `-- attributes.yml                 # Attributes files that will be merged and used to resolve templates
|-- aci-manifest.yml                   # Manifest
|-- templates
|   |-- etc
|   |   |-- templated.tmpl             # template file that will end up at /etc/templated
|   |   `-- templated.tmpl.cfg         # configuration of the targeted file, like user and mode (optional file)
|   `-- header.partial                 # template part that can be included in template files
|-- files
|   `-- dummy                          # Files to be copied to the same location in the target rootfs
|-- runlevels
|   |-- builder
|   |   `-- 10.prepare.sh              # Scripts to be run inside the builder to prepare the aci for build
|   |-- build
|   |   `-- 10.install.sh              # Scripts to be run when building inside aci's rootfs
|   |-- build-late
|   |   `-- 10.build-late.sh           # Scripts to be run when building inside aci's rootfs after the copy of files
|   |-- inherit-build-early
|   |   `-- 10.inherit-build-early.sh  # Scripts stored in ACI and executed while used as a dependency
|   |-- inherit-build-late
|   |   `-- 10.inherit-build-late.sh   # Scripts stored in ACI and executed while used as a dependency
|   |-- prestart-early
|   |   `-- 10.prestart-early.sh       # Scripts to be run when starting ACI before templating
|   `-- prestart-late
|       `-- 10.prestart-late.sh        # Scripts to be run when starting ACI after templating
`-- tests
    |-- dummy.bats                     # Bats tests for this ACI
    `-- wait.sh                        # Script to wait until the service is up before running tests
</code></pre>

<p>This project is already valid which means that you can build it and it will result in a runnable ACI (dgr always adds busybox to the ACI). But you probably want to customize it at this point.</p>

<p>The only mandatory information is the <code>aci-manifest.yml</code>, with only the aci <code>name:</code>. You can remove everything else depending on you needs.  </p>

<h2>
<a id="nice-other-features" class="anchor" href="#nice-other-features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Nice other features</h2>

<ul>
<li>builder runlevel with dependencies allow you build a project of any kind (java, php, go, node, ...) and release an aci without anything else than dgr and rkt on the host</li>
<li>dgr will tell you if you are not using the latest version of a dependency and will tell you which version is the latest</li>
<li>integrated test system that can be extended to support any kind of test system</li>
<li>working with <a href="https://github.com/appc/spec/blob/master/spec/pods.md">pods</a> as a unit during build too</li>
<li>build application version based on container name</li>
<li>extract aci version from the version of the software during installation</li>
</ul>

<h2>
<a id="how-its-working" class="anchor" href="#how-its-working" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How it's working</h2>

<p><img src="https://docs.google.com/drawings/d/1bSP6Z2X79xkp6deSNaZ-ShrAPjAPa4bzyjL4df2HLwk/pub?w=850"></p>

<p>dgr uses the <strong>builder</strong> information from the <strong>aci-manifest.yml</strong> to construct a rkt stage1. dgr then start rkt with this stage1 on an empty container with the final manifest of your aci (to have dependencies during build).</p>

<p>Inside rkt, the builder isolate the build process inside a <strong>systemd-nspawn</strong> on the builder's rootfs (with mount point on the final aci's rootfs and aci's home) and run the following steps :</p>

<ul>
<li>use internal dgr filesystem (busybox, openssl, wget, curl) for the builder if no dependencies (nothing in /usr/bin)</li>
<li>run <strong>builder</strong> runlevel</li>
<li>copy <strong>templater</strong> and <strong>inherit</strong> runlevels</li>
<li>isolate on final rootfs and run <strong>build</strong> runlevels</li>
<li>copy <strong>prestart</strong>, <strong>attributes</strong>, <strong>files</strong>, <strong>templates</strong>
</li>
<li>isolate on final rootfs and run <strong>build-late</strong> runlevels</li>
</ul>

<h2>
<a id="customizing" class="anchor" href="#customizing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Customizing</h2>

<h3>
<a id="the-manifest" class="anchor" href="#the-manifest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The manifest</h3>

<p>The dgr manifest looks like a light ACI manifest with extra builder and tester info. 
dgr will take the <code>aci</code> part and convert it to the format defined in the APPC spec.</p>

<p>Example of a <em>aci-manifest.yml</em>:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">name:</span> <span class="pl-s">example.com/myapp:0.1</span></span>

<span class="pl-s"><span class="pl-ent">builder:</span></span>
  <span class="pl-s"><span class="pl-ent">dependencies:</span></span>
    <span class="pl-s">- <span class="pl-s">example.com/base:1</span></span>

<span class="pl-s"><span class="pl-ent">tester:</span></span>
  <span class="pl-s"><span class="pl-ent">dependencies:</span></span>
    <span class="pl-s">- <span class="pl-s">example.com/base:1</span></span>

<span class="pl-s"><span class="pl-ent">aci:</span></span>
  <span class="pl-s"><span class="pl-ent">dependencies:</span></span>
    <span class="pl-s">- <span class="pl-s">example.com/base:1</span></span>
  <span class="pl-s"><span class="pl-ent">app:</span></span>
    <span class="pl-s"><span class="pl-ent">exec:</span></span>
      <span class="pl-s">- <span class="pl-s">/bin/myapp</span></span>
      <span class="pl-s">- <span class="pl-s">-c</span></span>
      <span class="pl-s">- <span class="pl-s">/etc/myapp/myapp.cfg</span></span>
    <span class="pl-s"><span class="pl-ent">mountPoints:</span></span>
      <span class="pl-s">- <span class="pl-ent">name:</span> <span class="pl-s">myapp-data</span></span>
        <span class="pl-s"><span class="pl-ent">path:</span> <span class="pl-s">/var/lib/myapp</span></span>
        <span class="pl-s"><span class="pl-ent">readOnly:</span> <span class="pl-s">false</span></span></pre></div>

<p>The <strong>name</strong>, well, is the name of the ACI you are building.</p>

<p><strong>builder</strong> node </p>

<p>Under the <strong>aci</strong> key, you can add every key that is defined in the <a href="https://github.com/appc/spec/blob/master/spec/aci.md">APPC spec</a> such as:</p>

<ul>
<li>
<strong>exec</strong> which contains the absolute path to the executable your want to run at the start of the ACI and its args.</li>
<li>
<strong>mountPoints</strong> even though you can do it on the command line with recent versions of RKT.</li>
<li>
<strong>isolators</strong>...</li>
</ul>

<p>Except <strong>handlers</strong> that are directly mapped to <strong>prestart</strong> runlevels </p>

<h3>
<a id="runlevels" class="anchor" href="#runlevels" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Runlevels</h3>

<p>The scripts in <code>runlevels/build</code> dir are executed during the build to install in the ACI everything you need. For instance if your dependencies are based on debian, a build script could look like:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-c">#!/bin/bash</span>
apt-get update
apt-get install -y myapp</pre></div>

<h3>
<a id="templates" class="anchor" href="#templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Templates</h3>

<p>You can create templates in your ACI. Templates are stored in the ACI as long as attributes and are resolved at start of the container.</p>

<p>Example:</p>

<p><em>templates/etc/resolv.conf.tmpl</em></p>

<pre><code>{{ range .dns.nameservers -}}
nameserver {{ . }}
{{ end }}

{{ if .dns.search -}}
search {{ range .dns.search }} {{.}} {{end}}
{{end}}
</code></pre>

<p><em>templates/etc/resolv.conf.tmpl.cfg</em></p>

<pre><code>uid: 0
gid: 0
mode: 0644
checkCmd: /dgr/bin/busybox true
</code></pre>

<p><code>checkCmd</code> is a command to run after the templating to check that the configuration is valid or fail container start.</p>

<p>When you have to reuse the same part in multiple templates, you can create a partial template like defined in the <a href="https://golang.org/pkg/text/template/#hdr-Nested_template_definitions">go templating</a>.</p>

<p><em>templates/header.partial</em></p>

<pre><code>{{define "header"}}
whatever
{{end}}
</code></pre>

<p>and include it in a template:</p>

<pre><code>{{template "header" .}}
</code></pre>

<p>Templater provides functions to manipulate data inside the template. Here is the list:</p>

<table>
<thead>
<tr>
<th>Tables</th>
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>base</td>
<td align="left">path.Base</td>
<td align="left"></td>
</tr>
<tr>
<td>split</td>
<td align="left">strings.Split</td>
<td align="left"></td>
</tr>
<tr>
<td>json</td>
<td align="left">UnmarshalJsonObject</td>
<td align="left"></td>
</tr>
<tr>
<td>jsonArray</td>
<td align="left">UnmarshalJsonArray</td>
<td align="left"></td>
</tr>
<tr>
<td>dir</td>
<td align="left">path.Dir</td>
<td align="left"></td>
</tr>
<tr>
<td>getenv</td>
<td align="left">os.Getenv</td>
<td align="left"></td>
</tr>
<tr>
<td>join</td>
<td align="left">strings.Join</td>
<td align="left"></td>
</tr>
<tr>
<td>datetime</td>
<td align="left">time.Now</td>
<td align="left"></td>
</tr>
<tr>
<td>toUpper</td>
<td align="left">strings.ToUpper</td>
<td align="left"></td>
</tr>
<tr>
<td>toLower</td>
<td align="left">strings.ToLower</td>
<td align="left"></td>
</tr>
<tr>
<td>contains</td>
<td align="left">strings.Contains</td>
<td align="left"></td>
</tr>
<tr>
<td>replace</td>
<td align="left">strings.Replace</td>
<td align="left"></td>
</tr>
<tr>
<td>orDef</td>
<td align="left">orDef</td>
<td align="left">if first element is nil, use second as default</td>
</tr>
<tr>
<td>orDefs</td>
<td align="left">orDefs</td>
<td align="left">if first array param is empty use second element to fill it</td>
</tr>
<tr>
<td>ifOrDef</td>
<td align="left">ifOrDef</td>
<td align="left">if first param is not nil, use second, else third</td>
</tr>
</tbody>
</table>

<p>It also provide all function defined by <a href="https://github.com/leekchan/gtf">gtf project</a></p>

<p><em>We can add functions on demand</em></p>

<h3>
<a id="attributes" class="anchor" href="#attributes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Attributes</h3>

<p>All the YAML files in the directory <strong>attributes</strong> are read by dgr. The first node of the YAML has to be "default" as it can be overridden in a POD or with a json in the env variable TEMPLATER_OVERRIDE in the cmd line.</p>

<p><em>attributes/resolv.conf.yml</em></p>

<pre><code>default:
  dns:
    nameservers:
      - "8.8.8.8"
      - "8.8.4.4"
    search:
      - bla.com
</code></pre>

<h3>
<a id="prestart" class="anchor" href="#prestart" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prestart</h3>

<p>dgr uses the "pre-start" eventHandler of the ACI to customize the ACI rootfs before the run depending on the instance or the environment.
It resolves at that time the templates so it has all the context needed to do that.
You can also run custom scripts before (prestart-early) or after (prestart-late) this template resolution. This is useful if you want to initialize a mountpoint with some data before running your app for instance.</p>

<p><em>runlevels/prestart-late/init.sh</em></p>

<div class="highlight highlight-source-shell"><pre><span class="pl-c">#!/bin/bash</span>
<span class="pl-c1">set</span> -e
/usr/bin/myapp-init</pre></div>

<h2>
<a id="running-the-aci" class="anchor" href="#running-the-aci" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Running the aci</h2>

<p>At this stage you should have a runnable aci. During build, dgr integrated into the aci a prestart that will take care of running templater using <code>templates</code> and <code>attributes</code></p>

<h3>
<a id="log-level" class="anchor" href="#log-level" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>log level</h3>

<p>Templates and default attribute values are integrated into the aci.
At start you can change log level of prestart scripts and the templater with the environment variable <code>--set-env=LOG_LEVEL=trace</code>.
default level is info. At <code>debug</code>, prestart shell script will activate debug (set -x). At level <code>trace</code>, templater will display the result of templating.</p>

<h3>
<a id="override-templates-attributes" class="anchor" href="#override-templates-attributes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Override template's attributes</h3>

<p>Default attributes values integrated in the aci can be overridden by adding a json tree in the environment variable <code>TEMPLATER_OVERRIDE</code></p>

<h3>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>example</h3>

<pre><code># sudo rkt --set-env=LOG_LEVEL=trace  --net=host --insecure-options=image run --interactive target/image.aci '--set-env=TEMPLATER_OVERRIDE={"dns":{"nameservers":["10.11.254.253","10.11.254.254"]}}'
</code></pre>

<h2>
<a id="troubleshoot" class="anchor" href="#troubleshoot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Troubleshoot</h2>

<p>dgr start by default with info log level. You can change this level with the <code>-L</code> command line argument.
The log level is also propagated to all runlevels with the environment variable: <strong>LOG_LEVEL</strong>.</p>

<p>You can activate debug on demand by including this code in your scripts:</p>

<pre><code>#!/dgr/bin/busybox sh
set -e
. /dgr/bin/functions.sh
isLevelEnabled "debug" &amp;&amp; set -x
</code></pre>

<p>Build it</p>

<div class="highlight highlight-source-shell"><pre>$ dgr -L debug build</pre></div>

<p>You can also debug the start of your container (prestart, templates) the same way</p>

<div class="highlight highlight-source-shell"><pre>$ rkt run --set-env=LOG_LEVEL=debug example.com/my-app</pre></div>

<p><strong>trace</strong> loglevel, will tell the templater to display the result</p>

<h2>
<a id="building-a-pod" class="anchor" href="#building-a-pod" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building a POD</h2>

<p>A pod is a group of aci that will build and run together as a single unit.</p>

<h3>
<a id="standard-filetree-for-pod" class="anchor" href="#standard-filetree-for-pod" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Standard FileTree for POD</h3>

<p>TODO</p>

<div class="highlight highlight-source-shell"><pre>├── aci-elasticsearch               <span class="pl-c"># Directory that match the pod app shortname (or name)</span>
│   ├── attributes
│   │   └── attributes.yml          <span class="pl-c"># Attributes file for templating in this ACI</span>
│   ├── files                       <span class="pl-c"># Files to be inserted into this ACI</span>
│   ...
├── pod-manifest.yml            <span class="pl-c"># Pod Manifest</span></pre></div>

<h2>
<a id="ok-but-concretely-how-should-i-use-it" class="anchor" href="#ok-but-concretely-how-should-i-use-it" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ok, but concretely how should I use it?</h2>

<p><em>have a look at the examples/ directory where you can find aci for various distrib</em></p>

<p>Depending on distrib, package manager and what you want to do, you will not work the same way. but globally there is 2 way of building an aci.</p>

<h4>
<a id="building-directly-inside-the-aci" class="anchor" href="#building-directly-inside-the-aci" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building directly inside the aci</h4>

<p>This is what you will see everywhere else in docker or rkt. You use the <strong>build</strong> and <strong>build-late</strong> runlevels and run commands on the the final rootfs (like apt-get install...)</p>

<h4>
<a id="building-outside-of-the-aci" class="anchor" href="#building-outside-of-the-aci" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building outside of the aci</h4>

<p>If you are using a package manager that support working outside of the target's rootfs or want to build a project, you will work outside of the stage1 directly inside the builder.
For example if you are buiding an aci for a go project from sources. you will prepare a <strong>builder</strong> with <strong>go</strong> to be able to build the project on the stage1 and put the binary on the aci's rootfs (go is not needed to run the aci).</p>

<p><em>At this step, everybody can build any kind of project, since nothing on the host is used to build the project and the aci.</em></p>

<p>Also, if you are using a package manager like <code>pacman</code> or <code>emerge</code>, you can build and install packages on the final <strong>rootfs</strong> without build dependencies nor the package manager.</p>

<h4>
<a id="note-about-dependencies" class="anchor" href="#note-about-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Note About dependencies</h4>

<p>Most package manager are not design for overlay and are working with a db file for installed software. this means than when your aci have multiple dependencies on the aci, the db files will overlap and the package manager will only see half of package installed.</p>

<p>As far as I know only <code>pacman</code>, that uses a file tree structure for install package, can support overlay.
If you are using a debian or similar. I recommand to limit the dependencies to only 2 layers. The base aci with debian minimal fs and one with the application you want.</p>

<h2>
<a id="comparison-with-alternatives" class="anchor" href="#comparison-with-alternatives" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comparison with alternatives</h2>

<h3>
<a id="dgr-vs-dockerfile" class="anchor" href="#dgr-vs-dockerfile" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>dgr vs Dockerfile</h3>

<p>A Dockerfile is purely configuration, describing the steps to build the container. It does not provide a common way of building containers across a team.
It does not provide scripts levels, ending with very long bash scripting for the run option in the dockerfile.
It does not handle configuration, nor at build time nor at runtime and does not support any kind of build outside of the container feature.</p>

<h3>
<a id="dgr-vs-acbuild" class="anchor" href="#dgr-vs-acbuild" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>dgr vs acbuild</h3>

<p>acbuild is a command line tools to build ACIs. It is more flexible than Dockerfiles as it can be wrapped by other tools such as Makefiles but like Dockerfiles it doesn't provide a standard way of configuring the images.</p>

<h2>
<a id="requirement" class="anchor" href="#requirement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Requirement</h2>

<ul>
<li>
<a href="https://github.com/coreos/rkt">rkt</a> in your <code>$PATH</code> or configured in dgr global conf</li>
<li>being root is required to call rkt</li>
<li>linux &gt;= 3.18 with overlay filesystem</li>
</ul>

<h2>
<a id="i-want-to-extend-dgr" class="anchor" href="#i-want-to-extend-dgr" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>I want to extend dgr</h2>

<p>If you think your idea can be integrated directly in the core of dgr, please create an issue or a pull request.</p>

<p>If you want want to extend the way the <strong>builder</strong> is working (attributes, templates, files, ...), you can create a new <strong>stage1 builder</strong> and replace the internal one with : </p>

<pre><code>...
builder:
  image: dgrtool.com/aci-builder:1
...
</code></pre>

<p>You can do the same for the <strong>tester</strong>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/blablacar/dgr">dgr</a> is maintained by <a href="https://github.com/blablacar">blablacar</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
